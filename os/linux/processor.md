# 各种不同的计算机系统

+ 单处理器系统
  在单处理器系统中, 有一个主CPU能够执行一个通用指令集, 包括来自于用户进程的指令. 绝大多数系统还包括其他特定目的的处理器, 它们可能以专用设备处理器(比如磁盘, 键盘, 图形控制器) 的形式出现. 所有这些专用处理器运行一个受限的指令集, 并不运行用户进程.
+ 多处理器系统
  多处理器系统又可分为非对称多处理(asymmetric multiprocessing)系统和对称多处理(Symmetric multiprocessing, SMP)系统.


# 操作系统

多道程序设计通过组织作业(编码或数据) 使CPU总有一个作业可执行, 从而提高了CPU的利用率.

分时系统(或多任务)是多道程序设计的延伸. 在分时系统中, 虽然CPU还是通过作业之间的切换来执行多个作业, 但是由于切换频率很高, 用户可以在程序运行期间与之进行交互.

装入到内存并执行的程序通常称为进程(process). 如果多个作业需要调入内存但没有足够的内存, 那么操作系统必须在这些作业之中做出选择, 这样的决策被称为`作业调度(job scheduling)`. 如果有多个任务同时需要执行, 那么操作系统必须做出选择, 这样的选择称为`CPU调度(CPU scheduling)`. 
虽然两者调度的对象都是任务/作业, 但`作业调度`是内存方面的调度, 而`CPU调度`则管理当前CPU时间片应分配给哪个进程使用.

# 双重模式操作
由于操作系统和用户共享了计算机系统的硬件和软件, 必须保证用户程序中的一个出错仅影响正在运行的程序. 采用共享, 许多进程可能会受到一个程序中的一个漏洞(bug)的不利影响. 操作系统的合理设计必须确保错误程序(或恶意程序)不会造成其他程序执行错误. 
为了确保操作系统的正常执行, 必须区分操作系统代码和用户定义代码的执行. 许多操作系统所采取的方式是提供硬件支持以允许区分各种执行模式. 至少需要两种独立的操作模式: `用户模式(user mode)`和`监督程序模式(monitor mode)`(也称为`管理模式(supervisor mode)`, `系统模式(system mode)`或`特权模式(privileged mode)`). 在计算机硬件中增加一个称为模式位(mode bit)的位以表示当前模式. 双重模式操作提供了保护操作系统和用户程序不受错误用户程序影响的手段. 其实现方法为: 将能引起损害的机器指令作为`特权指令(privileged instructions)`. 如果在用户模式下试图执行特权指令, 那么硬件并不执行该指令, 而是认为该指令非法, 并将其以陷阱的形式通知操作系统. 
最初的控制发生在操作系统中, 此时指令以内核模式来执行. 当控制权转到一个用户应用程序后, 模式变为用户模式. 最后, 通过中断, 陷阱或系统调用将控制权返回给操作系统. 
`系统调用`为用户程序请求操作系统代表用户程序完成预留给操作系统的任务提供了方法. 系统调用通常采用陷阱到中断向量的一个指定位置的方式.

# 定时器
必须确保操作系统能维持对CPU的控制, 也必须防止用户程序陷入死循环或不调用系统服务, 并且不将控制权返回到操作系统. 为了实现这一目标, 可使用`定时器(timer)`. `可变定时器(variable timer)`一般通过一个固定速率的时钟和计数器来实现. 操作系统在将控制权交给用户之前, 应确保设置好定时器以便产生中断. 如果定时器产生中断, 那么控制权会自动交给操作系统, 而操作系统可以将中断作为致命错误来处理, 也可以给予用户程序更多的时间. 显然, 用于修改定时器操作的指令是特权指令. 

# 进程管理
操作系统负责下述与进程管理相关的活动:
+ 创建和删除用户进程和系统进程
+ 挂起和重启进程
+ 提供进程同步机制
+ 提供进程通信机制
+ 提供死锁处理机制

# 内存管理
操作系统负责下列有关内存管理的活动:
+ 记录内存的哪部分正在被使用以及被谁使用
+ 当有内存空间时, 决定哪些进程可以装入内存
+ 根据需要分配和释放内存空间

# 存储管理
操作系统提供了统一的逻辑信息存储观点. 操作系统对存储设备的物理属性进行了抽象, 定义了逻辑存储单元, 即文件. 操作系统将文件映射到物理介质上, 并通过这些存储介质访问这些文件.

## 文件系统管理
操作系统负责下列有关文件管理的活动:
+ 创建和删除文件
+ 创建和删除目录来组织文件
+ 提供操作文件和目录的原语
+ 将文件映射到二级存储上
+ 在稳定存储介质上备份文件

## 大容量存储器管理
操作系统负责下列有关硬盘管理的活动:
+ 空闲空间管理
+ 存储空间分配
+ 硬盘调度

## 高速缓存
绝大多数系统都有指令高速缓存以保存下一个要执行的指令, 没有这一高速缓存, CPU将会等待多个时钟周期以便从内存中获取指令. 由于高速缓存大小有限, 所以高速缓存管理(cache management)的设计很重要. 对高速缓存大小和置换策略的仔细选择可以极大地提高性能.  
高速缓存又有硬件高速缓存(不受操作系统控制), 软件控制的高速缓存. 
内存可用作外存的高速缓存, 因为外存数据必须先复制到内存才可使用. 
对于多处理器环境, 每个CPU都有内部寄存器, 还有本地高速缓存. 对于这种环境, A的副本会同时出现在多个高速缓存中. 由于多个CPU可并发执行, 必须确保在一个高速缓存中对A值的更新马上反映在所有其他A所在的高速缓存中, 这称为高速缓存一致性(cache coherency). 这通常是硬件问题, 在操作系统级别之下处理. 

## I/O系统
I/O子系统包括如下几部分:
+ 一个包括缓冲, 高速缓存和假脱机的内存管理部分
+ 通用设备驱动器接口
+ 特定硬件设备的驱动程序

## 专用系统

+ 实时嵌入式系统
常用于控制特定应用的设备, 有明确而固定的时间约束, 处理必须在固定时间约束内完成. 
+ 多媒体系统
+ 手持系统

