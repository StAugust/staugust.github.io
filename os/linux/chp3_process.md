# 进程
程序本身不是进程, 程序只是被动实体, 是静态的, 而进程是活动实体, 它有一个程序计数器用来表示下一个要执行的命令和相关资源集合.
每个进程在操作系统内用`进程控制块(process control block, PCB)`来表示. 
## 调度程序
进程在其生命周期中会在各种调度队列之间迁移. 为了调度, 操作系统必须按某种方式从这些队列中选择进程, 进程选择是由相应的`调度程序(scheduler)`来执行的. `长期调度程序(long-term scheduler)`或`作业调度程序(job scheduler)`从缓冲池中选择进程, 并装入内存以准备执行. `短期调度程序(short-term scheduler)`或`CPU调度程序`从准备执行的进程中选择进程, 并为之分配CPU. 
长期调度程序控制多道程序设计的程序(内存中的进程数量). 
对于有些系统, 例如UNIX或微软Windows的分时系统, 通常没有长期调度程序, 只是简单地将所有新进程放在内存中以供短期调度程序使用. 这些系统的稳定性依赖于物理限制或用户的自我调整. 
有的操作系统, 如分时系统, 可能引入另外的中期调度程序(medium-term scheduler). 中期调度程序的核心思想是能将进程从内存(或从CPU竞争)中移出, 从而降低多道程序设计的程序. 之后, 进程能被重新调入内存, 并从中断处继续执行, 这种方案称为`交换(swapping)`. 

### 上下文切换
进程上下文用进程的PCB表示, 它包括CPU寄存器的值, 进程状态和内存管理信息等(比如说EFLAGS, 标志当前处于内核态/用户态). 通常, 通过执行一个状态保存(state save)来保存CPU当前状态, 之后执行一个状态恢复(state restore)重新开始运行. 

将CPU切换到另一个进程需要保存当前进程的状态, 并恢复另一个进程的状态, 这一任务称为`上下文切换(context switch)`. 

### 进程操作

#### 进程创建
进程在执行过程中, 能通过创建进程系统调用(create-process system call)创建多个新进程. 创建进程称为父进程(parent process), 而新进程称为子进程(child process). 每个新进程还可以再创建其他进程, 从而形成进程树. 
#### 进程终止
当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时, 进程终止. 这时, 进程可以返回状态值(通常为整数)到父进程(通过系统调用wait()). 所有进程资源(包括物理和虚拟内存, 打开文件和I/O缓冲)会被操作系统释放. 

## 进程间通信
进程间通信有两种基本模式: 
+ 共享内存
+ 消息传递
共享内存允许以最快的速度进行方便的通信, 在计算机中, 它可以达到内存的速度. 共享内存比消息传递快, 消息传递系统通常用系统调用来实现, 因此需要更多的内核介入, 消耗更多的时间. 

消息传递的一些问题:
- 直接或间接通信
- 同步或异步通信
- 自动或显式缓冲

### IPC系统的实例
#### POSIX共享内存

