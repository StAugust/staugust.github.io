# 线程
线程是CPU使用的基本单元, 由线程ID, 程序计数器, 寄存器集合和栈组成. 它与属于同一进程的其他线程共享代码段, 数据段和其他操作系统资源, 如打开文件和信号. 一个传统`重量级(heavyweight)`的进程只有单个控制线程.

多线程编程的优点:
+ 响应度高 交互程序使用多线程, 可将部分阻塞或执行较冗长的操作放到另一个线程, 而交互放在一个线程, 从而增加对用户的响应速度. 
+ 资源共享 线程默认共享它们所属进程的内存和资源.
+ 经济 创建进程需要的内存和资源分配比较昂贵, 创建和切换线程更为经济. 
+ 多处理器体系结构的利用 充分使用多处理器体系结构, 以便进程能并行运行在不同的处理器上. 

多线程模型:
有两种方法提供线程支持: 用户层的用户线程或内核层的内核线程. 用户线程受内核支持, 无需内核管理, 而内核线程由操作系统直接支持和管理. 所有当代操作系统都支持内核线程. 
用户线程和内核线程之间必然存在一种关系:
+ 多对一模型 将许多用户级线程映射到一个内核线程. 线程管理由线程库在用户空间进行, 因而效率较高, 但是如果一个线程执行了阻塞系统调用, 那么整个进程会阻塞. 因为任一时刻只有一个线程能访问内核, 多个线程不能并行运行在多处理器上. Green thread(Solaris所应用的线程库)就使用了这种模型, 另外还有GNU可移植线程(GNU Portable Threads). 
+ 一对一模型 将每个用户线程映射到一个内核线程. 提供了比多对一模型更好的并发功能, 它也允许多个线程能并行地运行在多处理器系统上. 这种模型的唯一缺点是每创建一个用户线程, 就需要创建一个相应的内核线程. 由于创建线程的开销会影响应用程序的性能, 所以这种模型的绝大多数实现限制了系统所支持的线程数量. Linux与Windows操作系统家族(包括Windows95, Windows98, Windows NT, Windows2000和Windows XP)实现了一对一模型. 
+ 多对多模型 多对多模型多路复用了许多用户线程到同样数量或者更小数量的内核线程上. 内核线程的数量可能与特定应用程序或特定机器有关(位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程). 

## 线程库
线程库(thread library)为程序员提供创建和管理线程的API. 主要有两种方法来实现线程库. 第一种是在用户空间中提供一个没有内核支持的库, 此库的所有代码和数据结构都存在于用户空间. 调用库中的一个函数只是导致了用户空间中的一个本地函数调用, 而非系统调用. 第二种方法则是执行一个由操作系统直接支持的内核级的库. 此时, 库的代码和数据结构存在于内核空间中. 调用库中的一个API函数通常会导致对内核的系统调用. 
目前主要使用的线程库有三种: 
+ POSIX Pthread Pthread作为POSIX标准的扩展, 可以提供用户级或内核级的库. 
+ Win32 Win32线程库是适用于Windows操作系统的内核级线程库. 
+ Java Java线程API允许线程在Java程序中直接创建和管理, 然而大多数jvm实例运行在宿主操作系统上, Java线程API通常采用宿主系统上的线程库来实现. 这意味着, 在Windows系统上, Java线程通常用Win32 API实现, 而在UNIX和Linux系统中采用Pthread. 

## 多线程相关问题

### 系统调用fork()和exec()
在多线程程序中, 系统调用fork()和exec()的语义有所改变. 如果程序中的一个线程调用fork(), 新的进程有两种可能, 一种复制所有线程, 另一种只复制调用了系统调用fork()的线程. 
如果一个线程调用了系统调用exec(), 那么exec()参数所指定的程序会替换整个进程, 包括所有线程. 

### 取消线程
线程取消(thread cancellation)是在线程完成之前来终止线程的任务. 
要取消的线程通常称为目标线程, 目标线程的取消可在如下两种情况下发生:
+ 异步取消(asynchronous cancellation) 一个线程立即终止目标线程
+ 延迟取消(deferred cancellation) 目标线程不断地检查它是否应该终止, 这允许目标线程有机会以有序方式来终止自己. 
如果资源已分配给要取消的线程或要取消的线程正在更新与其他线程所共享的数据, 那么取消就会有困难. 对于异步取消, 操作系统应回收取消线程的系统资源, 但通常并不回收所有资源, 因此, 异步取消线程并不会使所需的系统资源空闲. 相反采用延迟取消时, 一个线程指示目标线程要被取消, 不过只有当目标线程检查一个标志以确认它是否应该取消时才会发生取消. 这允许一个线程检查它是否是在安全的点被取消, Pthread称这些点为取消点(cancellation point). 

### 信号处理
信号在UNIX中用来通知进程某个特定事件已发生. 信号可以同步或异步接收, 所有信号具有同样模式:
+ 信号是由特定事件的发生所产生的. 
+ 产生的信号要发送到进程. 
+ 一旦发送, 信号必须加以处理. 

每个信号可能由两种可能的处理程序中的一种来处理:
+ 默认信号处理程序
+ 用户定义的信号处理程序
每个信号都有一个默认信号处理程序(default signal handler), 当处理信号时, 是在内核中运行的. 这种默认动作可以用用户定义的信号处理程序来改写. 
单线程的信号处理比较直接, 信号宗师发送给进程. 对于多线程程序, 发送信号就比较复杂, 因为进程可能有多个线程. 信号发送通常有以下几种做法:
+ 发送信号到信号所应用的线程
+ 发送信号到进程内的每个线程
+ 发送信号到进程内的某些特定线程
+ 规定一个特定线程以接收进程的所有信号

### 线程池
线程池(thread pool)的主要思想是在进程开始时创建一定数量的线程, 并放入池中以等待工作. 
线程池具有如下有点:
+ 通常用现有线程处理请求要比等待创建新的线程要快
+ 线程池限制了在任何时候可用线程的数量, 这对那些不支持大量并发线程的系统非常重要. 

### 线程特定数据
同属一个进程的线程间共享进程数据. 不过在有些情况下, 每个线程可能需要一定数据的自己的副本, 这种数据称为 线程特定数据(thread-specific data). 绝大多数线程库, 包括Win32和Pthread都提供了对线程特定数据的一定支持, Java也提供这种支持. 

### 调度程序激活
多线程编程的最后一个问题是内核与线程库之间的通信问题. 
一种解决用户线程库与内核间通信的方法称为`调度器激活(scheduler activation)`. 它的工作方式如下: 内核提供一组虚拟处理器(LWP, light weight process)给应用程序, 应用程序可调度用户线程到一个可用的虚拟处理器上. 进一步说, 内核必须告知与应用程序有关的特定事件. 这个过程称为`upcall`. `upcall`由具有upcall处理句柄的线程库处理, upcall处理句柄必须在虚拟处理器上运行. 当一个应用线程将要阻塞时, 事件引发一个upcall. 在这个例子中, 内核向应用程序发出一个upcall, 通知它线程阻塞并标识特殊的线程. 然后内核分配一个新的虚拟处理器给应用程序, 应用程序在这个新的虚拟处理器上运行upcall处理程序, 它保存阻塞线程状态和放弃阻塞线程运行的虚拟处理器. 然后upcall调度另一个适合在新的虚拟处理器上运行的线程, 当阻塞线程事件等待发生时, 内核向线程库发出另一个upcall, 来通知它先前阻塞的线程现在可以运行了. 此事件的upcall处理程序也需要一个虚拟处理器, 内核可能分配一个新的处理器或先占一个用户线程并在其虚拟处理器上运行upcall处理程序. 在使非阻塞线程可以运行后, 应用程序调度符合条件的线程来在一个适当的虚拟处理器上运行. 
