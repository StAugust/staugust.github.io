# Linux内核对内存的管理和使用

## 物理内存
物理内存分为以下几部分:
1. 内核模块 
Linux内核程序占据物理内存的开始部分
2. 高速缓冲区
高速缓冲区部分供硬盘或软件等块设备使用, 其中要扣除显卡内存和ROM BIOS所占用的内存地址范围640K~1MB. 当一个进程需要从块设备读取数据时, 系统会首先把数据读取到高速缓冲区, 当有数据要写入块设备时, 系统也是先将数据放到高速缓冲区, 再由块设备驱动程序写到相应的设备上. 
3. 虚拟盘
对于含有RAM虚拟盘的系统,主内存头部还要划去这一部分, 供虚拟盘存放数据.
4. 主内存区
内存的最后剩余部分即为主内存区, 供所有程序可以随时申请和使用. 内核程序在使用主内存区时, 也同样要先向内核内存管理模块提出申请, 并在申请成功后方能使用. 

------
由于计算机系统的实际可用物理内存有限, CPU中通常提供内存管理机制对系统中的内存进行有效的管理. 在Intel 80386及以后的CPU中提供了两种内存管理(地址变换)系统: 内存分段系统(Segmentation System)和分页系统(Paging System). 其中分页管理系统是可选择的, 由系统程序员通过编程来确定是否采用. 为了有效地使用物理内存, Linux系统同时采用了内存分段和分页管理机制.

## 内存地址空间概念
在进行地址映射操作时, 首先需要分清3中地址及它们之间的变换概念:
1. 程序(进程)的虚拟和逻辑地址
虚拟地址(Virtual Address)是指由程序产生的由段选择符(Segment Selector)和段内偏移地址(Shift Address)两个部分组成的地址, 通过分段地址变换机制处理或映射后,才能对应到物理内存地址上, 因此这种地址称为虚拟地址. 虚拟地址空间由GDT映射的全局地址空间和由LDT映射的局部地址空间组成, 选择符的索引部分由13个比特位表示,加上区分GDT和LDT的1个比特位, 因此Intel 80X86 CPU共可以索引16384个选择符, 如果每个段的长度都取最大值4G, 则最大虚拟地址空间范围是 16384 * 4G = 64T

逻辑地址(Logical Address)是指由程序产生的与段相关的偏移地址部分. 在Intel保护模式下, 即为程序执行代码段限长内的偏移地址(假定代码段, 数据段完全一样). 应用程序员仅需与逻辑地址打交道, 分段与分页机制对应用程序来说完全透明. 
2. CPU的线性地址
线性地址(Linear Address)是虚拟地址到物理地址变换之间的中间层, 是处理器可寻址的内存空间(称为线性地址空间)中的地址. 逻辑地址, 或者说是段中的偏移地址, 加上相应段的基地址(由段选择符及段长度等属性确定)就生成了一个线性地址. 如果启用了分页机制, 则线性地址还需要再转换一次, 才能得到物理地址. 如未采用分页机制, 则线性地址直接就是物理地址. Intel 80386的线性地址空间容量为4G. 
3. 实际物理内存地址
物理地址(Physical Address)是指出现在CPU外部地址总线上的寻址物理内存的地址信号, 是地址变换的最终结果地址. 如果启用了分页机制, 那么线性地址会使用页目录和页表中的项变换成物理地址. 

---
虚拟内存(Virtual Memory)是指计算机呈现出比实际拥有的内存大得多的内存量, 允许运行比实际系统拥有的内存大得多的程序. 
有时也有逻辑地址称为虚拟地址, 因为逻辑地址与虚拟内存空间的概念类似, 也是与实际物理内存容量无关. 

## 内存分段机制
实模式下, 直接使用段值, 保护模式下,段寄存器中存放的不再是被寻址段的基地址, 而是一个段描述符表(Segment Descriptor Table)中某一描述符项在表中的索引值, 索引值指定的段描述符项中含有需要寻址的内存段的基地址, 段的长度值和段的访问特权级别等信息. 
GDT(Global Descriptor Table)全局描述符表, 是主要的基本描述符表.
IDT(Interrupt Descriptor Table)中断描述符表, 保存有定义中断或异常处理过程的段描述符.
LDT(Local Descriptor Table)局部描述符表, 应用于多任务系统中, 通常每个任务使用一个LDT表, 作为对GDT表的扩充, 每个LDT表为对应任务提供更多的可用描述符项, 因而也为每个任务提供了可寻址内存空间的范围.
为了让CPU能定位GDT, IDT, LDT表, 需要为CPU分别设置GDTR, IDTR和LDTR三个特殊寄存器.

任务状态段TSS(Task State Segment)用于在任务切换时, CPU就把其寄存器等信息保存在该任务的TSS段中, 同时CPU使用新切换进任务的TSS段中信息来设置各寄存器, 以恢复此任务的执行环境. 
段寄存器?

## 内存分页机制
分页机制允许我们重新定向(变换)每次内存引用. 使用分页机制最普遍的场合是当系统内存实际上被分成很多凌乱的块时, 它可以建立一个大而连续的内存空间映像, 好让程序不用操心和管理这些分散的内存块. 分页机制增强了分段机制的性能, 另外, 页地址变换建立在段变换基础之上, 任何分页机制的保护措施并不会取代段变换的保护措施, 而只是更进一步的检查操作.
页目录表, 页表??


## CPU多任务和保护方式
Intel 80X86CPU有4个保护级, 0级具有最高优先级, 而3级优先级最低. 
当一个任务(进程)执行系统调用而陷入内核代码中执行时, 我们就称进程处于内核运行态(或简称内核态), 此时处理器处于特权级最高的(0级)内核代码中执行. 当进程处于内核态时, 执行的内核代码会使用当前进程的内核栈, 每个进程都有自己的内核栈. 当进程在执行用户自己的代码时, 则称其处于用户运行态(或简称用户态), 此时处理器处于特权级最低的(3级)用户代码中运行. 当正在执行用户程序而被中断程序中断时, 此时用户程序也可以象征性地称为处于进程的内核态, 因为中断处理程序将使用当前进程的内核栈. 

各种保护级的区别?

## 虚拟地址, 线性地址和物理地址之间的关系
