# 进程同步
协作进程是指可以与在系统内执行的其他进程互相影响的进程. 互相协作的进程可以直接共享逻辑地址空间(即代码和数据), 或者只通过文件或消息来共享数据. 本章主要部分都是关于进程同步(process synchronization)和协调(coordination)的. 

## 临界区问题
临界区(critical section), 在该区中, 进程可能改变共同变量, 更新一个表, 写一个文件等. 如果一个系统中多个进程都有临界区, 则需要设计一个以便进程协作的协议, 以确保党一个进程进入到临界区时, 没有其他进程可被允许在临界区执行, 这就是临界区问题(critical-section problem). 实现这一请求的代码段称为进入区(entry section), 临界区之后可有退出区(exit section), 其他代码称为剩余区(remainder section). 
临界区问题的解决必须满足如下三项要求:
+ 互斥(mutual exclusion) 如何进程P1在其临界区内执行, 那么其他进程都不能在其临界区内执行
+ 前进(progress) 如果没有进程在其临界区内执行, 且有进程需要进入临界区, 那么只有那些不在剩余区内执行的进程可参加选择, 以确定谁能下一个进入临界区, 而这种选择不能无限延迟. 
+ 有限等待(bounded waiting) 从一个进程做出进入临界区的请求, 直到该请求允许为止, 其他进程允许进入其临界区的次数有上限. (否则会出现饥饿现象, 某进程会一直得不到执行)

## 操作系统内核竞争
+ 当新打开或关闭一个文件时, 系统内维护打开文件的内核数据结构链表需要更新. 如果两个进程同时打开文件, 这两个独立的更新操作可能会产生竞争条件
+ 维护内存分配
+ 维护进程列表及处理中断处理程序的数据结构

## 两种处理操作系统内的临界区问题
抢占内核(preemptive kernel)与非抢占内核(nonpreemptive kernel). 抢占式内核允许处于内核模式的进程被抢占, 非抢占模式不允许处于内核模式的进程被抢占. 显然, 非抢占式内核从根本上不会导致竞争条件, 因为某一时刻只有一个进程处于内核模式. 然而, 抢占内核更适合实时编程, 响应更快, 允许实时进程抢占处于内核模式运行的其他进程. 

## Peterson算法

## 硬件同步

## 信号量
有的系统将二进制信号量称为互斥锁.
`自旋锁`有其优点, 进程在等待锁时不进行上下文切换, 而上下文切换可能需要花费相当长的时间. 自旋锁常用于多处理器系统中, 这样当一个线程在一个处理器上自旋时, 另一线程可在另一个处理器上在其临界区内执行. 
### 死锁与饥饿
具有等待队列的信号量的实现可能导致这样的情况: 两个或多个进程无限地等待一个事件, 而此事件只能由这些等待进程之一来产生, 当出现这样的状态时, 这些进程就称为死锁(deadlocked)了.
与死锁相关的另一个问题是无限期阻塞(indefinite blocking)或饥饿(starvation), 即进程在信号量内无限期等待. 如果对与信号量相关的链表按照LIFO顺序来增加和移动进程, 那么可能会发生无限期阻塞. 

## 经典同步问题
### 有限缓冲问题

### 读者-写者问题
读写锁的实现思想: 读进程共享以下数据:
```
semaphore mutex, wrt;
int readcount;
```
信号量mutex和wrt初始化为1, readcount初始化为0. 信号量wrt为读者和写者进程共用. 信号量mutex用于确保在更新变量readcount时的互斥. 变量readcount用来跟踪当前有多少进程正在读对象. 信号量wrt供写者作为互斥信号量, 它为第一个进入临界区和最后一个离开临界区的读者所使用, 而不被其他读者所使用. 
读写锁在以下情况下最为有用:
+ 当可以区分哪些进程只需要读共享数据而哪些进程只需要写共享数据
+ 当读者进程数比写进程数多时. 读写锁的创建开销通常比信号量或互斥锁大, 而这一开销可以通过允许多个读者来增加并发度的方法进行弥补. 

### 哲学家进餐问题
没有死锁的解决方案并不能消除饥饿的可能性. 

## 管程(monitor)

## 同步实例
### Solaris同步
### Windows XP同步
### Linux同步
### Pthread同步

## 原子事物
执行单个逻辑功能的一组指令或操作称为`事务`(transaction). 处理事务的主要问题是不管出现什么计算机系统的可能失败, 都要保证事务的原子性. 

已成功完成执行的终止事务称为`提交`(committed), 否则称为`撤销`(aborted).


